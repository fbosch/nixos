# Erlang Helpers

Sources:
- https://wiki.nixos.org/wiki/Language-specific_package_helpers

## Native-First Baseline

- Start with direct Erlang/rebar packaging patterns already used in nixpkgs.
- Escalate to helper tooling when dependency translation becomes repetitive.

## Decision Playbook

| Signal | Action |
|---|---|
| Hex metadata translation is the main blocker | use `hex2nix` |
| Build flow is rebar3-centric and code generation is unwanted | use `nix-rebar3` |
| Helper output requires heavy patching every update | return to direct packaging |

## Helpers

- `hex2nix` - Convert Hex packages to Nix expressions. Upstream: https://github.com/erlang-nix/hex2nix
- `nix-rebar3` - Build rebar3 projects without Nix code generation. Upstream: https://github.com/axelf4/nix-rebar3

## Failure Signatures and Fixes

- Signature: generated expressions do not match actual rebar lock/dependency state.
  - First fix: regenerate from clean dependency metadata.
  - Second fix: pin exact helper + source inputs and re-run generation.
- Signature: rebar3 builds succeed locally but fail in Nix sandbox.
  - First fix: add missing build-time tools to `nativeBuildInputs`.
  - Second fix: run phase-by-phase debug loop and capture first failing command.

## Abandon Helper When

- Generated files are unstable across minor dependency changes.
- Direct rebar-based packaging is simpler than maintaining generated artifacts.

## Example Implementation

```nix
{ pkgs, ... }:
let
  # Example: generated by hex2nix.
  hexPackages = import ./hex-packages-generated.nix { inherit pkgs; };
in
hexPackages.my-erlang-app
```

```nix
{ stdenv, erlang, rebar3 }:
stdenv.mkDerivation {
  pname = "my-rebar3-app";
  version = "1.0.0";
  src = ./.;
  nativeBuildInputs = [ erlang rebar3 ];
  buildPhase = "rebar3 compile";
  installPhase = "mkdir -p $out && cp -r _build/default/lib/* $out/";
}
```
